// Autogenerated from Pigeon (v22.6.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

enum CaptureSessionPreset {
  cif352x288,
  vga640x480,
  hd1280x720,
  hd1920x1080,
  hd4K3840x2160,
  photo,
}

enum EditTool {
  draw,
  clip,
  imageSticker,
  textSticker,
  mosaic,
  filter,
  adjust,
}

enum UiLocale {
  system,
  chineseSimplified,
  chineseTraditional,
  english,
  japanese,
  french,
  german,
  russian,
  vietnamese,
  korean,
  malay,
  italian,
  indonesian,
  portuguese,
  spanish,
  turkish,
  arabic,
  dutch,
}

enum AdjustTool {
  brightness,
  contrast,
  saturation,
}

enum DevicePosition {
  back,
  front,
}

enum ExposureMode {
  autoExpose,
  continuousAutoExposure,
}

enum FocusMode {
  autoFocus,
  continuousAutoFocus,
}

enum ImpactFeedbackStyle {
  light,
  medium,
  heavy,
}

enum MediaType {
  image,
  video,
}

enum VideoExportType {
  mov,
  mp4,
}

class ClipAspectRatio {
  ClipAspectRatio({
    required this.aspectRatioX,
    required this.aspectRatioY,
  });

  int aspectRatioX;

  int aspectRatioY;

  Object encode() {
    return <Object?>[
      aspectRatioX,
      aspectRatioY,
    ];
  }

  static ClipAspectRatio decode(Object result) {
    result as List<Object?>;
    return ClipAspectRatio(
      aspectRatioX: result[0]! as int,
      aspectRatioY: result[1]! as int,
    );
  }
}

class ClipOptions {
  ClipOptions({
    this.isCircle = false,
    this.aspectRatio,
  });

  bool isCircle;

  ClipAspectRatio? aspectRatio;

  Object encode() {
    return <Object?>[
      isCircle,
      aspectRatio,
    ];
  }

  static ClipOptions decode(Object result) {
    result as List<Object?>;
    return ClipOptions(
      isCircle: result[0]! as bool,
      aspectRatio: result[1] as ClipAspectRatio?,
    );
  }
}

class RawMediaData {
  RawMediaData({
    required this.path,
    required this.type,
    this.thumbPath,
    this.size,
  });

  String path;

  MediaType type;

  String? thumbPath;

  int? size;

  Object encode() {
    return <Object?>[
      path,
      type,
      thumbPath,
      size,
    ];
  }

  static RawMediaData decode(Object result) {
    result as List<Object?>;
    return RawMediaData(
      path: result[0]! as String,
      type: result[1]! as MediaType,
      thumbPath: result[2] as String?,
      size: result[3] as int?,
    );
  }
}

class RawPickerConfiguration {
  RawPickerConfiguration({
    this.maxSelectCount = 9,
    this.maxVideoSelectCount = 0,
    this.minVideoSelectCount = 0,
    this.allowMixSelect = true,
    this.maxPreviewCount = 20,
    this.initialIndex = 1,
    this.allowSelectImage = true,
    this.allowSelectVideo = true,
    this.downloadVideoBeforeSelecting = false,
    this.allowSelectGif = true,
    this.allowSelectLivePhoto = false,
    this.allowTakePhotoInLibrary = true,
    this.callbackDirectlyAfterTakingPhoto = false,
    this.allowEditImage = true,
    this.allowEditVideo = true,
    this.editAfterSelectThumbnailImage = false,
    this.cropVideoAfterSelectThumbnail = true,
    this.saveNewImageAfterEdit = true,
    this.allowSlideSelect = true,
    this.autoScrollWhenSlideSelectIsActive = true,
    this.autoScrollMaxSpeed = 600,
    this.allowDragSelect = false,
    this.allowSelectOriginal = true,
    this.alwaysRequestOriginal = false,
    this.showOriginalSizeWhenSelectOriginal = true,
    this.allowPreviewPhotos = true,
    this.showPreviewButtonInAlbum = true,
    this.showSelectCountOnDoneBtn = true,
    this.showSelectBtnWhenSingleSelect = false,
    this.showSelectedIndex = true,
    this.maxEditVideoTime = 10,
    this.maxSelectVideoDurationSeconds = 120,
    this.minSelectVideoDurationSeconds = 0,
    this.maxSelectVideoDataSizeKB,
    this.minSelectVideoDataSizeKB = 0,
    this.useCustomCamera = true,
  });

  /// Anything bigger than 1 will enable the multiple selection feature.
  /// Defaults to `9`.
  int maxSelectCount;

  /// A count for video max selection. Defaults to `0`. Warning: Only valid in
  /// mix selection mode. (i.e. [allowMixSelect] is `true`)
  int maxVideoSelectCount;

  /// A count for video min selection. Defaults to `0`.
  /// Warning: Only valid in mix selection mode i.e. [allowMixSelect] is `true`.
  int minVideoSelectCount;

  /// Whether photos and videos can be selected together.
  /// If set to `false`, only one video can be selected. Defaults to `true`.
  bool allowMixSelect;

  /// Preview selection max preview count, if the value is zero, only show
  /// `Camera`, `Album`, `Cancel` buttons. Defaults to `20`.
  int maxPreviewCount;

  /// The index of the first selected image, and the indices of subsequently
  /// selected images are incremented based on this value. Defaults to `1`.
  int initialIndex;

  /// If set to `false`, GIF and live photo cannot be selected either.
  /// Defaults to `true`.
  bool allowSelectImage;

  /// If set to `false`, videos cannot be selected either. Defaults to `true`.
  bool allowSelectVideo;

  /// If set to `true`, videos on iCloud will be downloaded before selection.
  /// Defaults to `false`.
  bool downloadVideoBeforeSelecting;

  /// Allow select GIF, it only controls whether it is displayed in GIF form.
  /// If value is `false`, the GIF logo is not displayed. Defaults to `true`.
  bool allowSelectGif;

  /// Allow select live photo, it only controls whether it is displayed in
  /// live photo form. If value is `false`, the live photo logo is not displayed.
  /// Defaults to `false`.
  bool allowSelectLivePhoto;

  /// Allow take photos in the album. Defaults to `true`.
  /// Warning: If [allowTakePhoto] and [allowRecordVideo] are both `false`,
  /// it will not be displayed.
  bool allowTakePhotoInLibrary;

  /// Whether to callback directly after taking a photo. Defaults to `false`.
  bool callbackDirectlyAfterTakingPhoto;

  /// Allows edit images. Defaults to `true`.
  bool allowEditImage;

  /// Warning: The video can only be edited when no photos are selected, or only
  /// one video is selected, and the selection callback is executed immediately
  /// after editing is completed.
  bool allowEditVideo;

  /// After selecting a image/video in the thumbnail interface, enter the editing
  /// interface directly. Defaults to `false`.
  ///
  /// Note: Editing image is only valid when [allowEditImage] is `true` and
  /// [maxSelectCount] is `1`. Editing video is only valid when [allowEditVideo]
  /// is `true` and [maxSelectCount] is `1`.
  bool editAfterSelectThumbnailImage;

  /// Only valid when [allowMixSelect] is `false` and [allowEditVideo] is `true`.
  /// Defaults to `true`.  If you  want to crop the video after select thumbnail
  /// under [allowMixSelect] is `true`, please use [editAfterSelectThumbnailImage].
  bool cropVideoAfterSelectThumbnail;

  /// Save the edited image to the album after editing. Defaults to `true`.
  bool saveNewImageAfterEdit;

  /// If `true`, you can slide select photos in album. Defaults to `true`.
  bool allowSlideSelect;

  /// When slide select is active, will auto scroll to top or bottom when your
  /// finger at the top or bottom. Defaults to `true`.
  bool autoScrollWhenSlideSelectIsActive;

  /// The max speed (pt/s) of auto scroll. Defaults to `600`.
  double autoScrollMaxSpeed;

  /// If `true`, you can drag select photo when preview selection style.
  /// Defaults to `false`.
  bool allowDragSelect;

  /// Allow select full image. Defaults to `true`.
  bool allowSelectOriginal;

  /// Always return the original photo. Warning: Only valid when
  /// [allowSelectOriginal] is `false`. Defaults to `false`.
  bool alwaysRequestOriginal;

  /// Whether to show the total size of selected photos when selecting the
  /// original image. Defaults to `true`.
  ///
  /// Note: The framework uses a conversion ratio of 1KB=1024Byte, while the
  /// system album uses 1KB=1000Byte, so the displayed photo size within the
  /// framework will be smaller than the size in the system album.
  bool showOriginalSizeWhenSelectOriginal;

  /// Allow access to the preview large image interface (whether to
  /// allow access to the large image interface after clicking the thumbnail
  /// image). Defaults to `true`.
  bool allowPreviewPhotos;

  /// Whether to show the preview button (i.e. the preview button in the lower
  /// left corner of the thumbnail interface). Defaults to `true`.
  bool showPreviewButtonInAlbum;

  /// Whether to display the selected count on the button. Defaults to `true`.
  bool showSelectCountOnDoneBtn;

  /// In single selection mode, whether to display the selection button.
  /// Defaults to `false`.
  bool showSelectBtnWhenSingleSelect;

  /// Display the index of the selected photos. Defaults to `true`.
  bool showSelectedIndex;

  /// Maximum cropping time when editing video, unit: second. Defaults to `10`.
  int maxEditVideoTime;

  /// Allow to choose the maximum duration of the video. Defaults to `120`.
  int maxSelectVideoDurationSeconds;

  /// Allow to choose the minimum duration of the video. Defaults to `0`.
  int minSelectVideoDurationSeconds;

  /// Allow to choose the maximum data size of the video (in KB).
  /// Defaults to `null` (no limit).
  double? maxSelectVideoDataSizeKB;

  /// Allow to choose the minimum data size of the video. Defaults to `0` KB.
  double minSelectVideoDataSizeKB;

  /// Whether to use custom camera. Defaults to `true`.
  bool useCustomCamera;

  Object encode() {
    return <Object?>[
      maxSelectCount,
      maxVideoSelectCount,
      minVideoSelectCount,
      allowMixSelect,
      maxPreviewCount,
      initialIndex,
      allowSelectImage,
      allowSelectVideo,
      downloadVideoBeforeSelecting,
      allowSelectGif,
      allowSelectLivePhoto,
      allowTakePhotoInLibrary,
      callbackDirectlyAfterTakingPhoto,
      allowEditImage,
      allowEditVideo,
      editAfterSelectThumbnailImage,
      cropVideoAfterSelectThumbnail,
      saveNewImageAfterEdit,
      allowSlideSelect,
      autoScrollWhenSlideSelectIsActive,
      autoScrollMaxSpeed,
      allowDragSelect,
      allowSelectOriginal,
      alwaysRequestOriginal,
      showOriginalSizeWhenSelectOriginal,
      allowPreviewPhotos,
      showPreviewButtonInAlbum,
      showSelectCountOnDoneBtn,
      showSelectBtnWhenSingleSelect,
      showSelectedIndex,
      maxEditVideoTime,
      maxSelectVideoDurationSeconds,
      minSelectVideoDurationSeconds,
      maxSelectVideoDataSizeKB,
      minSelectVideoDataSizeKB,
      useCustomCamera,
    ];
  }

  static RawPickerConfiguration decode(Object result) {
    result as List<Object?>;
    return RawPickerConfiguration(
      maxSelectCount: result[0]! as int,
      maxVideoSelectCount: result[1]! as int,
      minVideoSelectCount: result[2]! as int,
      allowMixSelect: result[3]! as bool,
      maxPreviewCount: result[4]! as int,
      initialIndex: result[5]! as int,
      allowSelectImage: result[6]! as bool,
      allowSelectVideo: result[7]! as bool,
      downloadVideoBeforeSelecting: result[8]! as bool,
      allowSelectGif: result[9]! as bool,
      allowSelectLivePhoto: result[10]! as bool,
      allowTakePhotoInLibrary: result[11]! as bool,
      callbackDirectlyAfterTakingPhoto: result[12]! as bool,
      allowEditImage: result[13]! as bool,
      allowEditVideo: result[14]! as bool,
      editAfterSelectThumbnailImage: result[15]! as bool,
      cropVideoAfterSelectThumbnail: result[16]! as bool,
      saveNewImageAfterEdit: result[17]! as bool,
      allowSlideSelect: result[18]! as bool,
      autoScrollWhenSlideSelectIsActive: result[19]! as bool,
      autoScrollMaxSpeed: result[20]! as double,
      allowDragSelect: result[21]! as bool,
      allowSelectOriginal: result[22]! as bool,
      alwaysRequestOriginal: result[23]! as bool,
      showOriginalSizeWhenSelectOriginal: result[24]! as bool,
      allowPreviewPhotos: result[25]! as bool,
      showPreviewButtonInAlbum: result[26]! as bool,
      showSelectCountOnDoneBtn: result[27]! as bool,
      showSelectBtnWhenSingleSelect: result[28]! as bool,
      showSelectedIndex: result[29]! as bool,
      maxEditVideoTime: result[30]! as int,
      maxSelectVideoDurationSeconds: result[31]! as int,
      minSelectVideoDurationSeconds: result[32]! as int,
      maxSelectVideoDataSizeKB: result[33] as double?,
      minSelectVideoDataSizeKB: result[34]! as double,
      useCustomCamera: result[35]! as bool,
    );
  }
}

class RawEditConfiguration {
  RawEditConfiguration({
    this.tools = const [],
    this.clipOptions,
    this.adjustTools = const [],
    this.showClipDirectlyIfOnlyHasClipTool = false,
    this.impactFeedbackWhenAdjustSliderValueIsZero = true,
    this.impactFeedbackStyle = ImpactFeedbackStyle.medium,
    this.dimClippedAreaDuringAdjustments = false,
    this.minimumZoomScale = 1.0,
  });

  /// Edit image tools.
  /// Default order: `draw`, `clip`, `textSticker`, `mosaic`, `filter`, `adjust`.
  List<EditTool> tools;

  /// Edit clip type and ratio for the editor.
  ClipOptions? clipOptions;

  /// Adjust image tools. Default order: `brightness`, `contrast`, `saturation`.
  List<AdjustTool> adjustTools;

  /// If image edit tools only have clip and this property is `true`,
  /// the clipping interface will be displayed directly. Defaults to `false`.
  bool showClipDirectlyIfOnlyHasClipTool;

  /// Give an impact feedback when the adjust slider value is zero.
  /// Defaults to `true`.
  bool impactFeedbackWhenAdjustSliderValueIsZero;

  /// Impact feedback style. Defaults to `medium`.
  ImpactFeedbackStyle impactFeedbackStyle;

  /// Whether to keep the clipped area dimmed during adjustments.
  /// Defaults to `false`.
  bool dimClippedAreaDuringAdjustments;

  /// Minimum zoom scale, allowing the user to make the edited photo smaller,
  /// so it does not overlap top and bottom tools menu. Defaults to `1.0`.
  double minimumZoomScale;

  Object encode() {
    return <Object?>[
      tools,
      clipOptions,
      adjustTools,
      showClipDirectlyIfOnlyHasClipTool,
      impactFeedbackWhenAdjustSliderValueIsZero,
      impactFeedbackStyle,
      dimClippedAreaDuringAdjustments,
      minimumZoomScale,
    ];
  }

  static RawEditConfiguration decode(Object result) {
    result as List<Object?>;
    return RawEditConfiguration(
      tools: (result[0] as List<Object?>?)!.cast<EditTool>(),
      clipOptions: result[1] as ClipOptions?,
      adjustTools: (result[2] as List<Object?>?)!.cast<AdjustTool>(),
      showClipDirectlyIfOnlyHasClipTool: result[3]! as bool,
      impactFeedbackWhenAdjustSliderValueIsZero: result[4]! as bool,
      impactFeedbackStyle: result[5]! as ImpactFeedbackStyle,
      dimClippedAreaDuringAdjustments: result[6]! as bool,
      minimumZoomScale: result[7]! as double,
    );
  }
}

class RawCameraConfiguration {
  RawCameraConfiguration({
    this.allowTakePhoto = true,
    this.allowRecordVideo = true,
    this.minDurationSeconds = 0,
    this.maxDurationSeconds = 30,
    this.isFrontVideoMirrored = true,
    this.sessionPreset = CaptureSessionPreset.hd1920x1080,
    this.focusMode = FocusMode.continuousAutoFocus,
    this.exposureMode = ExposureMode.continuousAutoExposure,
    this.directoryPath,
    this.imageName,
    this.showFlashSwitch = true,
    this.allowSwitchCamera = true,
    this.tapToRecordVideo = true,
    this.enableWideCameras = true,
    this.videoExportType = VideoExportType.mp4,
    this.devicePosition = DevicePosition.back,
  });

  /// Allow taking photos in the camera. Defaults to `true`.
  bool allowTakePhoto;

  /// Allow video recording in the camera. Defaults to `true`.
  bool allowRecordVideo;

  /// Minimum recording duration. Defaults to `0`.
  int minDurationSeconds;

  /// Maximum recording duration. Defaults to `30`, minimum is `1`.
  int maxDurationSeconds;

  /// Indicates whether the video flowing through the connection should be
  /// mirrored about its vertical axis. Defaults to `true`.
  bool isFrontVideoMirrored;

  /// Video resolution. Defaults to [CaptureSessionPreset.hd1920x1080].
  CaptureSessionPreset sessionPreset;

  /// Camera focus mode. Defaults to [FocusMode.continuousAutoFocus].
  FocusMode focusMode;

  /// Camera exposure mode. Defaults to [ExposureMode.continuousAutoExposure].
  ExposureMode exposureMode;

  /// Directory path for saving the file. Defaults to `null`, temporary directory.
  String? directoryPath;

  /// Image file name for saving the image or thumbnail file.
  /// Defaults to `null`, random UUID with `multi_media_` prefix.
  String? imageName;

  /// Camera flash switch. Defaults to `true`.
  bool showFlashSwitch;

  /// Whether to support switch camera. Defaults to `true`.
  bool allowSwitchCamera;

  /// Flag to enable tap-to-record functionality. Default is `true`. If
  /// [allowTakePhoto] is set to `true`, [tapToRecordVideo] will be ignored.
  bool tapToRecordVideo;

  /// Enable the use of wide cameras (on supported devices). Defaults to `true`.
  bool enableWideCameras;

  /// Video export format for recording/editing video. Defaults to `mp4`.
  VideoExportType videoExportType;

  /// The default camera position after entering the camera. Defaults to `back`.
  DevicePosition devicePosition;

  Object encode() {
    return <Object?>[
      allowTakePhoto,
      allowRecordVideo,
      minDurationSeconds,
      maxDurationSeconds,
      isFrontVideoMirrored,
      sessionPreset,
      focusMode,
      exposureMode,
      directoryPath,
      imageName,
      showFlashSwitch,
      allowSwitchCamera,
      tapToRecordVideo,
      enableWideCameras,
      videoExportType,
      devicePosition,
    ];
  }

  static RawCameraConfiguration decode(Object result) {
    result as List<Object?>;
    return RawCameraConfiguration(
      allowTakePhoto: result[0]! as bool,
      allowRecordVideo: result[1]! as bool,
      minDurationSeconds: result[2]! as int,
      maxDurationSeconds: result[3]! as int,
      isFrontVideoMirrored: result[4]! as bool,
      sessionPreset: result[5]! as CaptureSessionPreset,
      focusMode: result[6]! as FocusMode,
      exposureMode: result[7]! as ExposureMode,
      directoryPath: result[8] as String?,
      imageName: result[9] as String?,
      showFlashSwitch: result[10]! as bool,
      allowSwitchCamera: result[11]! as bool,
      tapToRecordVideo: result[12]! as bool,
      enableWideCameras: result[13]! as bool,
      videoExportType: result[14]! as VideoExportType,
      devicePosition: result[15]! as DevicePosition,
    );
  }
}


class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    }    else if (value is CaptureSessionPreset) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    }    else if (value is EditTool) {
      buffer.putUint8(130);
      writeValue(buffer, value.index);
    }    else if (value is UiLocale) {
      buffer.putUint8(131);
      writeValue(buffer, value.index);
    }    else if (value is AdjustTool) {
      buffer.putUint8(132);
      writeValue(buffer, value.index);
    }    else if (value is DevicePosition) {
      buffer.putUint8(133);
      writeValue(buffer, value.index);
    }    else if (value is ExposureMode) {
      buffer.putUint8(134);
      writeValue(buffer, value.index);
    }    else if (value is FocusMode) {
      buffer.putUint8(135);
      writeValue(buffer, value.index);
    }    else if (value is ImpactFeedbackStyle) {
      buffer.putUint8(136);
      writeValue(buffer, value.index);
    }    else if (value is MediaType) {
      buffer.putUint8(137);
      writeValue(buffer, value.index);
    }    else if (value is VideoExportType) {
      buffer.putUint8(138);
      writeValue(buffer, value.index);
    }    else if (value is ClipAspectRatio) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    }    else if (value is ClipOptions) {
      buffer.putUint8(140);
      writeValue(buffer, value.encode());
    }    else if (value is RawMediaData) {
      buffer.putUint8(141);
      writeValue(buffer, value.encode());
    }    else if (value is RawPickerConfiguration) {
      buffer.putUint8(142);
      writeValue(buffer, value.encode());
    }    else if (value is RawEditConfiguration) {
      buffer.putUint8(143);
      writeValue(buffer, value.encode());
    }    else if (value is RawCameraConfiguration) {
      buffer.putUint8(144);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : CaptureSessionPreset.values[value];
      case 130: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : EditTool.values[value];
      case 131: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : UiLocale.values[value];
      case 132: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : AdjustTool.values[value];
      case 133: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : DevicePosition.values[value];
      case 134: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : ExposureMode.values[value];
      case 135: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : FocusMode.values[value];
      case 136: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : ImpactFeedbackStyle.values[value];
      case 137: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : MediaType.values[value];
      case 138: 
        final int? value = readValue(buffer) as int?;
        return value == null ? null : VideoExportType.values[value];
      case 139: 
        return ClipAspectRatio.decode(readValue(buffer)!);
      case 140: 
        return ClipOptions.decode(readValue(buffer)!);
      case 141: 
        return RawMediaData.decode(readValue(buffer)!);
      case 142: 
        return RawPickerConfiguration.decode(readValue(buffer)!);
      case 143: 
        return RawEditConfiguration.decode(readValue(buffer)!);
      case 144: 
        return RawCameraConfiguration.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class MultiMediaApi {
  /// Constructor for [MultiMediaApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  MultiMediaApi({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<RawMediaData?> openCamera(RawCameraConfiguration cameraConfig, RawPickerConfiguration pickerConfig, RawEditConfiguration editConfig) async {
    final String pigeonVar_channelName = 'dev.flutter.pigeon.multi_media_picker.MultiMediaApi.openCamera$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[cameraConfig, pickerConfig, editConfig]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as RawMediaData?);
    }
  }
}
