// Autogenerated from Pigeon (v22.6.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum CaptureSessionPreset: Int {
  case cif352x288 = 0
  case vga640x480 = 1
  case hd1280x720 = 2
  case hd1920x1080 = 3
  case hd4K3840x2160 = 4
  case photo = 5
}

enum EditTool: Int {
  case draw = 0
  case clip = 1
  case imageSticker = 2
  case textSticker = 3
  case mosaic = 4
  case filter = 5
  case adjust = 6
}

enum UiLocale: Int {
  case system = 0
  case chineseSimplified = 1
  case chineseTraditional = 2
  case english = 3
  case japanese = 4
  case french = 5
  case german = 6
  case russian = 7
  case vietnamese = 8
  case korean = 9
  case malay = 10
  case italian = 11
  case indonesian = 12
  case portuguese = 13
  case spanish = 14
  case turkish = 15
  case arabic = 16
  case dutch = 17
}

enum AdjustTool: Int {
  case brightness = 0
  case contrast = 1
  case saturation = 2
}

enum DevicePosition: Int {
  case back = 0
  case front = 1
}

enum ExposureMode: Int {
  case autoExpose = 0
  case continuousAutoExposure = 1
}

enum FocusMode: Int {
  case autoFocus = 0
  case continuousAutoFocus = 1
}

enum ImpactFeedbackStyle: Int {
  case light = 0
  case medium = 1
  case heavy = 2
}

enum MediaType: Int {
  case image = 0
  case video = 1
}

enum VideoExportType: Int {
  case mov = 0
  case mp4 = 1
}

/// Generated class from Pigeon that represents data sent in messages.
struct ClipAspectRatio {
  var aspectRatioX: Int64
  var aspectRatioY: Int64



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ClipAspectRatio? {
    let aspectRatioX = pigeonVar_list[0] as! Int64
    let aspectRatioY = pigeonVar_list[1] as! Int64

    return ClipAspectRatio(
      aspectRatioX: aspectRatioX,
      aspectRatioY: aspectRatioY
    )
  }
  func toList() -> [Any?] {
    return [
      aspectRatioX,
      aspectRatioY,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct ClipOptions {
  var isCircle: Bool
  var aspectRatio: ClipAspectRatio? = nil



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ClipOptions? {
    let isCircle = pigeonVar_list[0] as! Bool
    let aspectRatio: ClipAspectRatio? = nilOrValue(pigeonVar_list[1])

    return ClipOptions(
      isCircle: isCircle,
      aspectRatio: aspectRatio
    )
  }
  func toList() -> [Any?] {
    return [
      isCircle,
      aspectRatio,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RawMediaData {
  var path: String
  var type: MediaType
  var thumbPath: String? = nil
  var size: Int64? = nil



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RawMediaData? {
    let path = pigeonVar_list[0] as! String
    let type = pigeonVar_list[1] as! MediaType
    let thumbPath: String? = nilOrValue(pigeonVar_list[2])
    let size: Int64? = nilOrValue(pigeonVar_list[3])

    return RawMediaData(
      path: path,
      type: type,
      thumbPath: thumbPath,
      size: size
    )
  }
  func toList() -> [Any?] {
    return [
      path,
      type,
      thumbPath,
      size,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RawPickerConfiguration {
  /// Anything bigger than 1 will enable the multiple selection feature.
  /// Defaults to `9`.
  var maxSelectCount: Int64
  /// A count for video max selection. Defaults to `0`. Warning: Only valid in
  /// mix selection mode. (i.e. [allowMixSelect] is `true`)
  var maxVideoSelectCount: Int64
  /// A count for video min selection. Defaults to `0`.
  /// Warning: Only valid in mix selection mode i.e. [allowMixSelect] is `true`.
  var minVideoSelectCount: Int64
  /// Whether photos and videos can be selected together.
  /// If set to `false`, only one video can be selected. Defaults to `true`.
  var allowMixSelect: Bool
  /// Preview selection max preview count, if the value is zero, only show
  /// `Camera`, `Album`, `Cancel` buttons. Defaults to `20`.
  var maxPreviewCount: Int64
  /// The index of the first selected image, and the indices of subsequently
  /// selected images are incremented based on this value. Defaults to `1`.
  var initialIndex: Int64
  /// If set to `false`, GIF and live photo cannot be selected either.
  /// Defaults to `true`.
  var allowSelectImage: Bool
  /// If set to `false`, videos cannot be selected either. Defaults to `true`.
  var allowSelectVideo: Bool
  /// If set to `true`, videos on iCloud will be downloaded before selection.
  /// Defaults to `false`.
  var downloadVideoBeforeSelecting: Bool
  /// Allow select GIF, it only controls whether it is displayed in GIF form.
  /// If value is `false`, the GIF logo is not displayed. Defaults to `true`.
  var allowSelectGif: Bool
  /// Allow select live photo, it only controls whether it is displayed in
  /// live photo form. If value is `false`, the live photo logo is not displayed.
  /// Defaults to `false`.
  var allowSelectLivePhoto: Bool
  /// Allow take photos in the album. Defaults to `true`.
  /// Warning: If [allowTakePhoto] and [allowRecordVideo] are both `false`,
  /// it will not be displayed.
  var allowTakePhotoInLibrary: Bool
  /// Whether to callback directly after taking a photo. Defaults to `false`.
  var callbackDirectlyAfterTakingPhoto: Bool
  /// Allows edit images. Defaults to `true`.
  var allowEditImage: Bool
  /// Warning: The video can only be edited when no photos are selected, or only
  /// one video is selected, and the selection callback is executed immediately
  /// after editing is completed.
  var allowEditVideo: Bool
  /// After selecting a image/video in the thumbnail interface, enter the editing
  /// interface directly. Defaults to `false`.
  ///
  /// Note: Editing image is only valid when [allowEditImage] is `true` and
  /// [maxSelectCount] is `1`. Editing video is only valid when [allowEditVideo]
  /// is `true` and [maxSelectCount] is `1`.
  var editAfterSelectThumbnailImage: Bool
  /// Only valid when [allowMixSelect] is `false` and [allowEditVideo] is `true`.
  /// Defaults to `true`.  If you  want to crop the video after select thumbnail
  /// under [allowMixSelect] is `true`, please use [editAfterSelectThumbnailImage].
  var cropVideoAfterSelectThumbnail: Bool
  /// Save the edited image to the album after editing. Defaults to `true`.
  var saveNewImageAfterEdit: Bool
  /// If `true`, you can slide select photos in album. Defaults to `true`.
  var allowSlideSelect: Bool
  /// When slide select is active, will auto scroll to top or bottom when your
  /// finger at the top or bottom. Defaults to `true`.
  var autoScrollWhenSlideSelectIsActive: Bool
  /// The max speed (pt/s) of auto scroll. Defaults to `600`.
  var autoScrollMaxSpeed: Double
  /// If `true`, you can drag select photo when preview selection style.
  /// Defaults to `false`.
  var allowDragSelect: Bool
  /// Allow select full image. Defaults to `true`.
  var allowSelectOriginal: Bool
  /// Always return the original photo. Warning: Only valid when
  /// [allowSelectOriginal] is `false`. Defaults to `false`.
  var alwaysRequestOriginal: Bool
  /// Whether to show the total size of selected photos when selecting the
  /// original image. Defaults to `true`.
  ///
  /// Note: The framework uses a conversion ratio of 1KB=1024Byte, while the
  /// system album uses 1KB=1000Byte, so the displayed photo size within the
  /// framework will be smaller than the size in the system album.
  var showOriginalSizeWhenSelectOriginal: Bool
  /// Allow access to the preview large image interface (whether to
  /// allow access to the large image interface after clicking the thumbnail
  /// image). Defaults to `true`.
  var allowPreviewPhotos: Bool
  /// Whether to show the preview button (i.e. the preview button in the lower
  /// left corner of the thumbnail interface). Defaults to `true`.
  var showPreviewButtonInAlbum: Bool
  /// Whether to display the selected count on the button. Defaults to `true`.
  var showSelectCountOnDoneBtn: Bool
  /// In single selection mode, whether to display the selection button.
  /// Defaults to `false`.
  var showSelectBtnWhenSingleSelect: Bool
  /// Display the index of the selected photos. Defaults to `true`.
  var showSelectedIndex: Bool
  /// Maximum cropping time when editing video, unit: second. Defaults to `10`.
  var maxEditVideoTime: Int64
  /// Allow to choose the maximum duration of the video. Defaults to `120`.
  var maxSelectVideoDurationSeconds: Int64
  /// Allow to choose the minimum duration of the video. Defaults to `0`.
  var minSelectVideoDurationSeconds: Int64
  /// Allow to choose the maximum data size of the video (in KB).
  /// Defaults to `null` (no limit).
  var maxSelectVideoDataSizeKB: Double? = nil
  /// Allow to choose the minimum data size of the video. Defaults to `0` KB.
  var minSelectVideoDataSizeKB: Double
  /// Whether to use custom camera. Defaults to `true`.
  var useCustomCamera: Bool



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RawPickerConfiguration? {
    let maxSelectCount = pigeonVar_list[0] as! Int64
    let maxVideoSelectCount = pigeonVar_list[1] as! Int64
    let minVideoSelectCount = pigeonVar_list[2] as! Int64
    let allowMixSelect = pigeonVar_list[3] as! Bool
    let maxPreviewCount = pigeonVar_list[4] as! Int64
    let initialIndex = pigeonVar_list[5] as! Int64
    let allowSelectImage = pigeonVar_list[6] as! Bool
    let allowSelectVideo = pigeonVar_list[7] as! Bool
    let downloadVideoBeforeSelecting = pigeonVar_list[8] as! Bool
    let allowSelectGif = pigeonVar_list[9] as! Bool
    let allowSelectLivePhoto = pigeonVar_list[10] as! Bool
    let allowTakePhotoInLibrary = pigeonVar_list[11] as! Bool
    let callbackDirectlyAfterTakingPhoto = pigeonVar_list[12] as! Bool
    let allowEditImage = pigeonVar_list[13] as! Bool
    let allowEditVideo = pigeonVar_list[14] as! Bool
    let editAfterSelectThumbnailImage = pigeonVar_list[15] as! Bool
    let cropVideoAfterSelectThumbnail = pigeonVar_list[16] as! Bool
    let saveNewImageAfterEdit = pigeonVar_list[17] as! Bool
    let allowSlideSelect = pigeonVar_list[18] as! Bool
    let autoScrollWhenSlideSelectIsActive = pigeonVar_list[19] as! Bool
    let autoScrollMaxSpeed = pigeonVar_list[20] as! Double
    let allowDragSelect = pigeonVar_list[21] as! Bool
    let allowSelectOriginal = pigeonVar_list[22] as! Bool
    let alwaysRequestOriginal = pigeonVar_list[23] as! Bool
    let showOriginalSizeWhenSelectOriginal = pigeonVar_list[24] as! Bool
    let allowPreviewPhotos = pigeonVar_list[25] as! Bool
    let showPreviewButtonInAlbum = pigeonVar_list[26] as! Bool
    let showSelectCountOnDoneBtn = pigeonVar_list[27] as! Bool
    let showSelectBtnWhenSingleSelect = pigeonVar_list[28] as! Bool
    let showSelectedIndex = pigeonVar_list[29] as! Bool
    let maxEditVideoTime = pigeonVar_list[30] as! Int64
    let maxSelectVideoDurationSeconds = pigeonVar_list[31] as! Int64
    let minSelectVideoDurationSeconds = pigeonVar_list[32] as! Int64
    let maxSelectVideoDataSizeKB: Double? = nilOrValue(pigeonVar_list[33])
    let minSelectVideoDataSizeKB = pigeonVar_list[34] as! Double
    let useCustomCamera = pigeonVar_list[35] as! Bool

    return RawPickerConfiguration(
      maxSelectCount: maxSelectCount,
      maxVideoSelectCount: maxVideoSelectCount,
      minVideoSelectCount: minVideoSelectCount,
      allowMixSelect: allowMixSelect,
      maxPreviewCount: maxPreviewCount,
      initialIndex: initialIndex,
      allowSelectImage: allowSelectImage,
      allowSelectVideo: allowSelectVideo,
      downloadVideoBeforeSelecting: downloadVideoBeforeSelecting,
      allowSelectGif: allowSelectGif,
      allowSelectLivePhoto: allowSelectLivePhoto,
      allowTakePhotoInLibrary: allowTakePhotoInLibrary,
      callbackDirectlyAfterTakingPhoto: callbackDirectlyAfterTakingPhoto,
      allowEditImage: allowEditImage,
      allowEditVideo: allowEditVideo,
      editAfterSelectThumbnailImage: editAfterSelectThumbnailImage,
      cropVideoAfterSelectThumbnail: cropVideoAfterSelectThumbnail,
      saveNewImageAfterEdit: saveNewImageAfterEdit,
      allowSlideSelect: allowSlideSelect,
      autoScrollWhenSlideSelectIsActive: autoScrollWhenSlideSelectIsActive,
      autoScrollMaxSpeed: autoScrollMaxSpeed,
      allowDragSelect: allowDragSelect,
      allowSelectOriginal: allowSelectOriginal,
      alwaysRequestOriginal: alwaysRequestOriginal,
      showOriginalSizeWhenSelectOriginal: showOriginalSizeWhenSelectOriginal,
      allowPreviewPhotos: allowPreviewPhotos,
      showPreviewButtonInAlbum: showPreviewButtonInAlbum,
      showSelectCountOnDoneBtn: showSelectCountOnDoneBtn,
      showSelectBtnWhenSingleSelect: showSelectBtnWhenSingleSelect,
      showSelectedIndex: showSelectedIndex,
      maxEditVideoTime: maxEditVideoTime,
      maxSelectVideoDurationSeconds: maxSelectVideoDurationSeconds,
      minSelectVideoDurationSeconds: minSelectVideoDurationSeconds,
      maxSelectVideoDataSizeKB: maxSelectVideoDataSizeKB,
      minSelectVideoDataSizeKB: minSelectVideoDataSizeKB,
      useCustomCamera: useCustomCamera
    )
  }
  func toList() -> [Any?] {
    return [
      maxSelectCount,
      maxVideoSelectCount,
      minVideoSelectCount,
      allowMixSelect,
      maxPreviewCount,
      initialIndex,
      allowSelectImage,
      allowSelectVideo,
      downloadVideoBeforeSelecting,
      allowSelectGif,
      allowSelectLivePhoto,
      allowTakePhotoInLibrary,
      callbackDirectlyAfterTakingPhoto,
      allowEditImage,
      allowEditVideo,
      editAfterSelectThumbnailImage,
      cropVideoAfterSelectThumbnail,
      saveNewImageAfterEdit,
      allowSlideSelect,
      autoScrollWhenSlideSelectIsActive,
      autoScrollMaxSpeed,
      allowDragSelect,
      allowSelectOriginal,
      alwaysRequestOriginal,
      showOriginalSizeWhenSelectOriginal,
      allowPreviewPhotos,
      showPreviewButtonInAlbum,
      showSelectCountOnDoneBtn,
      showSelectBtnWhenSingleSelect,
      showSelectedIndex,
      maxEditVideoTime,
      maxSelectVideoDurationSeconds,
      minSelectVideoDurationSeconds,
      maxSelectVideoDataSizeKB,
      minSelectVideoDataSizeKB,
      useCustomCamera,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RawEditConfiguration {
  /// Edit image tools.
  /// Default order: `draw`, `clip`, `textSticker`, `mosaic`, `filter`, `adjust`.
  var tools: [EditTool]
  /// Edit clip type and ratio for the editor.
  var clipOptions: ClipOptions? = nil
  /// Adjust image tools. Default order: `brightness`, `contrast`, `saturation`.
  var adjustTools: [AdjustTool]
  /// If image edit tools only have clip and this property is `true`,
  /// the clipping interface will be displayed directly. Defaults to `false`.
  var showClipDirectlyIfOnlyHasClipTool: Bool
  /// Give an impact feedback when the adjust slider value is zero.
  /// Defaults to `true`.
  var impactFeedbackWhenAdjustSliderValueIsZero: Bool
  /// Impact feedback style. Defaults to `medium`.
  var impactFeedbackStyle: ImpactFeedbackStyle
  /// Whether to keep the clipped area dimmed during adjustments.
  /// Defaults to `false`.
  var dimClippedAreaDuringAdjustments: Bool
  /// Minimum zoom scale, allowing the user to make the edited photo smaller,
  /// so it does not overlap top and bottom tools menu. Defaults to `1.0`.
  var minimumZoomScale: Double



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RawEditConfiguration? {
    let tools = pigeonVar_list[0] as! [EditTool]
    let clipOptions: ClipOptions? = nilOrValue(pigeonVar_list[1])
    let adjustTools = pigeonVar_list[2] as! [AdjustTool]
    let showClipDirectlyIfOnlyHasClipTool = pigeonVar_list[3] as! Bool
    let impactFeedbackWhenAdjustSliderValueIsZero = pigeonVar_list[4] as! Bool
    let impactFeedbackStyle = pigeonVar_list[5] as! ImpactFeedbackStyle
    let dimClippedAreaDuringAdjustments = pigeonVar_list[6] as! Bool
    let minimumZoomScale = pigeonVar_list[7] as! Double

    return RawEditConfiguration(
      tools: tools,
      clipOptions: clipOptions,
      adjustTools: adjustTools,
      showClipDirectlyIfOnlyHasClipTool: showClipDirectlyIfOnlyHasClipTool,
      impactFeedbackWhenAdjustSliderValueIsZero: impactFeedbackWhenAdjustSliderValueIsZero,
      impactFeedbackStyle: impactFeedbackStyle,
      dimClippedAreaDuringAdjustments: dimClippedAreaDuringAdjustments,
      minimumZoomScale: minimumZoomScale
    )
  }
  func toList() -> [Any?] {
    return [
      tools,
      clipOptions,
      adjustTools,
      showClipDirectlyIfOnlyHasClipTool,
      impactFeedbackWhenAdjustSliderValueIsZero,
      impactFeedbackStyle,
      dimClippedAreaDuringAdjustments,
      minimumZoomScale,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RawCameraConfiguration {
  /// Allow taking photos in the camera. Defaults to `true`.
  var allowTakePhoto: Bool
  /// Allow video recording in the camera. Defaults to `true`.
  var allowRecordVideo: Bool
  /// Minimum recording duration. Defaults to `0`.
  var minDurationSeconds: Int64
  /// Maximum recording duration. Defaults to `30`, minimum is `1`.
  var maxDurationSeconds: Int64
  /// Indicates whether the video flowing through the connection should be
  /// mirrored about its vertical axis. Defaults to `true`.
  var isVideoMirrored: Bool
  /// Video resolution. Defaults to [CaptureSessionPreset.hd1920x1080].
  var sessionPreset: CaptureSessionPreset
  /// Camera focus mode. Defaults to [FocusMode.continuousAutoFocus].
  var focusMode: FocusMode
  /// Camera exposure mode. Defaults to [ExposureMode.continuousAutoExposure].
  var exposureMode: ExposureMode
  /// Directory path for saving the file. Defaults to `null`, temporary directory.
  var fileDirectoryPath: String? = nil
  /// File name for saving the file.
  /// Defaults to `null`, random UUID with `multi_media_` prefix.
  var fileName: String? = nil
  /// Camera flash switch. Defaults to `true`.
  var showFlashSwitch: Bool
  /// Whether to support switch camera. Defaults to `true`.
  var allowSwitchCamera: Bool
  /// Flag to enable tap-to-record functionality. Default is `true`. If
  /// [allowTakePhoto] is set to `true`, [tapToRecordVideo] will be ignored.
  var tapToRecordVideo: Bool
  /// Enable the use of wide cameras (on supported devices). Defaults to `true`.
  var enableWideCameras: Bool
  /// Video export format for recording/editing video. Defaults to `mp4`.
  var videoExportType: VideoExportType
  /// The default camera position after entering the camera. Defaults to `back`.
  var devicePosition: DevicePosition



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RawCameraConfiguration? {
    let allowTakePhoto = pigeonVar_list[0] as! Bool
    let allowRecordVideo = pigeonVar_list[1] as! Bool
    let minDurationSeconds = pigeonVar_list[2] as! Int64
    let maxDurationSeconds = pigeonVar_list[3] as! Int64
    let isVideoMirrored = pigeonVar_list[4] as! Bool
    let sessionPreset = pigeonVar_list[5] as! CaptureSessionPreset
    let focusMode = pigeonVar_list[6] as! FocusMode
    let exposureMode = pigeonVar_list[7] as! ExposureMode
    let fileDirectoryPath: String? = nilOrValue(pigeonVar_list[8])
    let fileName: String? = nilOrValue(pigeonVar_list[9])
    let showFlashSwitch = pigeonVar_list[10] as! Bool
    let allowSwitchCamera = pigeonVar_list[11] as! Bool
    let tapToRecordVideo = pigeonVar_list[12] as! Bool
    let enableWideCameras = pigeonVar_list[13] as! Bool
    let videoExportType = pigeonVar_list[14] as! VideoExportType
    let devicePosition = pigeonVar_list[15] as! DevicePosition

    return RawCameraConfiguration(
      allowTakePhoto: allowTakePhoto,
      allowRecordVideo: allowRecordVideo,
      minDurationSeconds: minDurationSeconds,
      maxDurationSeconds: maxDurationSeconds,
      isVideoMirrored: isVideoMirrored,
      sessionPreset: sessionPreset,
      focusMode: focusMode,
      exposureMode: exposureMode,
      fileDirectoryPath: fileDirectoryPath,
      fileName: fileName,
      showFlashSwitch: showFlashSwitch,
      allowSwitchCamera: allowSwitchCamera,
      tapToRecordVideo: tapToRecordVideo,
      enableWideCameras: enableWideCameras,
      videoExportType: videoExportType,
      devicePosition: devicePosition
    )
  }
  func toList() -> [Any?] {
    return [
      allowTakePhoto,
      allowRecordVideo,
      minDurationSeconds,
      maxDurationSeconds,
      isVideoMirrored,
      sessionPreset,
      focusMode,
      exposureMode,
      fileDirectoryPath,
      fileName,
      showFlashSwitch,
      allowSwitchCamera,
      tapToRecordVideo,
      enableWideCameras,
      videoExportType,
      devicePosition,
    ]
  }
}

private class messagesPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CaptureSessionPreset(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return EditTool(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return UiLocale(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return AdjustTool(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return DevicePosition(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ExposureMode(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FocusMode(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ImpactFeedbackStyle(rawValue: enumResultAsInt)
      }
      return nil
    case 137:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return MediaType(rawValue: enumResultAsInt)
      }
      return nil
    case 138:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return VideoExportType(rawValue: enumResultAsInt)
      }
      return nil
    case 139:
      return ClipAspectRatio.fromList(self.readValue() as! [Any?])
    case 140:
      return ClipOptions.fromList(self.readValue() as! [Any?])
    case 141:
      return RawMediaData.fromList(self.readValue() as! [Any?])
    case 142:
      return RawPickerConfiguration.fromList(self.readValue() as! [Any?])
    case 143:
      return RawEditConfiguration.fromList(self.readValue() as! [Any?])
    case 144:
      return RawCameraConfiguration.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class messagesPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CaptureSessionPreset {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? EditTool {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? UiLocale {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? AdjustTool {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? DevicePosition {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? ExposureMode {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? FocusMode {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? ImpactFeedbackStyle {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? MediaType {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? VideoExportType {
      super.writeByte(138)
      super.writeValue(value.rawValue)
    } else if let value = value as? ClipAspectRatio {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? ClipOptions {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? RawMediaData {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? RawPickerConfiguration {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? RawEditConfiguration {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? RawCameraConfiguration {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class messagesPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return messagesPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return messagesPigeonCodecWriter(data: data)
  }
}

class messagesPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = messagesPigeonCodec(readerWriter: messagesPigeonCodecReaderWriter())
}


/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol MultiMediaApi {
  func openCamera(cameraConfig: RawCameraConfiguration, pickerConfig: RawPickerConfiguration, editConfig: RawEditConfiguration, completion: @escaping (Result<RawMediaData?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class MultiMediaApiSetup {
  static var codec: FlutterStandardMessageCodec { messagesPigeonCodec.shared }
  /// Sets up an instance of `MultiMediaApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: MultiMediaApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let openCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.multi_media_picker.MultiMediaApi.openCamera\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      openCameraChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraConfigArg = args[0] as! RawCameraConfiguration
        let pickerConfigArg = args[1] as! RawPickerConfiguration
        let editConfigArg = args[2] as! RawEditConfiguration
        api.openCamera(cameraConfig: cameraConfigArg, pickerConfig: pickerConfigArg, editConfig: editConfigArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      openCameraChannel.setMessageHandler(nil)
    }
  }
}
