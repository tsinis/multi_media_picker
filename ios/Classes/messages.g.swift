// Autogenerated from Pigeon (v22.6.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum CaptureSessionPreset: Int {
  case cif352x288 = 0
  case vga640x480 = 1
  case hd1280x720 = 2
  case hd1920x1080 = 3
  case hd4K3840x2160 = 4
  case photo = 5
}

enum CropType: Int {
  case rectangle = 0
  case circle = 1
}

enum DevicePosition: Int {
  case back = 0
  case front = 1
}

enum ExposureMode: Int {
  case autoExpose = 0
  case continuousAutoExposure = 1
}

enum FocusMode: Int {
  case autoFocus = 0
  case continuousAutoFocus = 1
}

enum MediaType: Int {
  case image = 0
  case video = 1
}

enum VideoExportType: Int {
  case mov = 0
  case mp4 = 1
}

/// Generated class from Pigeon that represents data sent in messages.
struct CropAspectRatio {
  var aspectRatioX: Int64
  var aspectRatioY: Int64



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CropAspectRatio? {
    let aspectRatioX = pigeonVar_list[0] as! Int64
    let aspectRatioY = pigeonVar_list[1] as! Int64

    return CropAspectRatio(
      aspectRatioX: aspectRatioX,
      aspectRatioY: aspectRatioY
    )
  }
  func toList() -> [Any?] {
    return [
      aspectRatioX,
      aspectRatioY,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct CropOptions {
  var type: CropType
  var aspectRatio: CropAspectRatio? = nil



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CropOptions? {
    let type = pigeonVar_list[0] as! CropType
    let aspectRatio: CropAspectRatio? = nilOrValue(pigeonVar_list[1])

    return CropOptions(
      type: type,
      aspectRatio: aspectRatio
    )
  }
  func toList() -> [Any?] {
    return [
      type,
      aspectRatio,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RawMediaData {
  var path: String
  var type: MediaType
  var thumbPath: String? = nil
  var size: Int64? = nil



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RawMediaData? {
    let path = pigeonVar_list[0] as! String
    let type = pigeonVar_list[1] as! MediaType
    let thumbPath: String? = nilOrValue(pigeonVar_list[2])
    let size: Int64? = nilOrValue(pigeonVar_list[3])

    return RawMediaData(
      path: path,
      type: type,
      thumbPath: thumbPath,
      size: size
    )
  }
  func toList() -> [Any?] {
    return [
      path,
      type,
      thumbPath,
      size,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RawCameraConfiguration {
  /// The type of media to use. Defaults to [MediaType.image].
  var mediaType: MediaType
  /// Max size of the media file in KB.
  var maxSizeKB: Int64? = nil
  /// The locale of the camera. Defaults to the system locale.
  var locale: String? = nil
  var cropOptions: CropOptions? = nil
  /// Allow taking photos in the camera. Defaults to `true`.
  var allowTakePhoto: Bool
  /// Allow video recording in the camera. Defaults to `true`.
  var allowRecordVideo: Bool
  /// Minimum recording duration. Defaults to `0`.
  var minDurationSeconds: Int64
  /// Maximum recording duration. Defaults to `30`, minimum is `1`.
  var maxDurationSeconds: Int64
  /// Indicates whether the video flowing through the connection
  /// should be mirrored about its vertical axis. Defaults to `true`.
  var isVideoMirrored: Bool
  /// Video resolution. Defaults to [CaptureSessionPreset.hd1920x1080].
  var sessionPreset: CaptureSessionPreset
  /// Camera focus mode. Defaults to [FocusMode.continuousAutoFocus].
  var focusMode: FocusMode
  /// Camera exposure mode. Defaults to [ExposureMode.continuousAutoExposure].
  var exposureMode: ExposureMode
  /// Camera flash switch. Defaults to `true`.
  var showFlashSwitch: Bool
  /// Whether to support switch camera. Defaults to `true`.
  var allowSwitchCamera: Bool
  /// Flag to enable tap-to-record functionality. Default is `true`.
  /// If [allowTakePhoto] is set to `true`, [tapToRecordVideo] will be ignored.
  var tapToRecordVideo: Bool
  /// Enable the use of wide cameras (on supported devices). Defaults to `true`.
  var enableWideCameras: Bool
  /// Video export format for recording/editing video. Defaults to `mp4`.
  var videoExportType: VideoExportType
  /// The default camera position after entering the camera. Defaults to `back`.
  var devicePosition: DevicePosition



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RawCameraConfiguration? {
    let mediaType = pigeonVar_list[0] as! MediaType
    let maxSizeKB: Int64? = nilOrValue(pigeonVar_list[1])
    let locale: String? = nilOrValue(pigeonVar_list[2])
    let cropOptions: CropOptions? = nilOrValue(pigeonVar_list[3])
    let allowTakePhoto = pigeonVar_list[4] as! Bool
    let allowRecordVideo = pigeonVar_list[5] as! Bool
    let minDurationSeconds = pigeonVar_list[6] as! Int64
    let maxDurationSeconds = pigeonVar_list[7] as! Int64
    let isVideoMirrored = pigeonVar_list[8] as! Bool
    let sessionPreset = pigeonVar_list[9] as! CaptureSessionPreset
    let focusMode = pigeonVar_list[10] as! FocusMode
    let exposureMode = pigeonVar_list[11] as! ExposureMode
    let showFlashSwitch = pigeonVar_list[12] as! Bool
    let allowSwitchCamera = pigeonVar_list[13] as! Bool
    let tapToRecordVideo = pigeonVar_list[14] as! Bool
    let enableWideCameras = pigeonVar_list[15] as! Bool
    let videoExportType = pigeonVar_list[16] as! VideoExportType
    let devicePosition = pigeonVar_list[17] as! DevicePosition

    return RawCameraConfiguration(
      mediaType: mediaType,
      maxSizeKB: maxSizeKB,
      locale: locale,
      cropOptions: cropOptions,
      allowTakePhoto: allowTakePhoto,
      allowRecordVideo: allowRecordVideo,
      minDurationSeconds: minDurationSeconds,
      maxDurationSeconds: maxDurationSeconds,
      isVideoMirrored: isVideoMirrored,
      sessionPreset: sessionPreset,
      focusMode: focusMode,
      exposureMode: exposureMode,
      showFlashSwitch: showFlashSwitch,
      allowSwitchCamera: allowSwitchCamera,
      tapToRecordVideo: tapToRecordVideo,
      enableWideCameras: enableWideCameras,
      videoExportType: videoExportType,
      devicePosition: devicePosition
    )
  }
  func toList() -> [Any?] {
    return [
      mediaType,
      maxSizeKB,
      locale,
      cropOptions,
      allowTakePhoto,
      allowRecordVideo,
      minDurationSeconds,
      maxDurationSeconds,
      isVideoMirrored,
      sessionPreset,
      focusMode,
      exposureMode,
      showFlashSwitch,
      allowSwitchCamera,
      tapToRecordVideo,
      enableWideCameras,
      videoExportType,
      devicePosition,
    ]
  }
}

private class messagesPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CaptureSessionPreset(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return CropType(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return DevicePosition(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ExposureMode(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FocusMode(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return MediaType(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return VideoExportType(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      return CropAspectRatio.fromList(self.readValue() as! [Any?])
    case 137:
      return CropOptions.fromList(self.readValue() as! [Any?])
    case 138:
      return RawMediaData.fromList(self.readValue() as! [Any?])
    case 139:
      return RawCameraConfiguration.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class messagesPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CaptureSessionPreset {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? CropType {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? DevicePosition {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? ExposureMode {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? FocusMode {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? MediaType {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? VideoExportType {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? CropAspectRatio {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? CropOptions {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? RawMediaData {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? RawCameraConfiguration {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class messagesPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return messagesPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return messagesPigeonCodecWriter(data: data)
  }
}

class messagesPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = messagesPigeonCodec(readerWriter: messagesPigeonCodecReaderWriter())
}


/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol MultiMediaApi {
  func openCamera(cameraConfig: RawCameraConfiguration, completion: @escaping (Result<RawMediaData?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class MultiMediaApiSetup {
  static var codec: FlutterStandardMessageCodec { messagesPigeonCodec.shared }
  /// Sets up an instance of `MultiMediaApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: MultiMediaApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let openCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.multi_media_picker.MultiMediaApi.openCamera\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      openCameraChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraConfigArg = args[0] as! RawCameraConfiguration
        api.openCamera(cameraConfig: cameraConfigArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      openCameraChannel.setMessageHandler(nil)
    }
  }
}
